/** GENERATED BY zen-cli
DON'T MODIFY MANUALLY */
import { UsageContext } from "./UsageContext";
import { ContactDetail } from "./ContactDetail";
import { CodeableConcept } from "./CodeableConcept";
import { uri } from "./uri";
import { dateTime } from "./dateTime";
import { canonical } from "./canonical";
import { DomainResource } from "./DomainResource";
import { markdown } from "./markdown";
import { Element } from "./Element";
import { code } from "./code";
import { Identifier } from "./Identifier";
import { BackboneElement } from "./BackboneElement";
/** A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models. */
export interface ConceptMap extends DomainResource {
    resourceType: 'ConceptMap';
    /** Natural language description of the concept map */
    description?: markdown;
    sourceCanonical?: canonical;
    /** Date last changed */
    date?: dateTime;
    targetUri?: uri;
    _targetUri?: Element;
    /** Same source and target systems */
    group?: Array<ConceptMapGroup>;
    /** Name of the publisher (organization or individual) */
    publisher?: string;
    _sourceCanonical?: Element;
    /** Intended jurisdiction for concept map (if applicable) */
    jurisdiction?: Array<CodeableConcept>;
    _publisher?: Element;
    /** Why this concept map is defined */
    purpose?: markdown;
    _date?: Element;
    /** Name for this concept map (computer friendly) */
    name?: string;
    _sourceUri?: Element;
    _status?: Element;
    _experimental?: Element;
    /** The context that the content is intended to support */
    useContext?: Array<UsageContext>;
    /** Use and/or publishing restrictions */
    copyright?: markdown;
    /** For testing purposes, not real usage */
    experimental?: boolean;
    /** Name for this concept map (human friendly) */
    title?: string;
    _description?: Element;
    _purpose?: Element;
    targetCanonical?: canonical;
    /** draft | active | retired | unknown */
    status: `${ConceptMapStatus}`;
    sourceUri?: uri;
    _name?: Element;
    /** Canonical identifier for this concept map, represented as a URI (globally unique) */
    url?: uri;
    /** Additional identifier for the concept map */
    identifier?: Identifier;
    _targetCanonical?: Element;
    _copyright?: Element;
    _title?: Element;
    /** Business version of the concept map */
    version?: string;
    _version?: Element;
    /** Contact details for the publisher */
    contact?: Array<ContactDetail>;
    _url?: Element;
}
/** provided | fixed | other-map */
export declare enum ConceptMapGroupUnmappedMode {
    Fixed = "fixed",
    OtherMap = "other-map",
    Provided = "provided"
}
/** What to do when there is no mapping for the source concept */
export interface ConceptMapUnmapped extends BackboneElement {
    /** provided | fixed | other-map */
    mode: `${ConceptMapGroupUnmappedMode}`;
    _mode?: Element;
    /** Fixed code when mode = fixed */
    code?: code;
    _code?: Element;
    /** Display for the code */
    display?: string;
    _display?: Element;
    /** canonical reference to an additional ConceptMap to use for mapping if the source concept is unmapped */
    url?: canonical;
    _url?: Element;
}
/** relatedto | equivalent | equal | wider | subsumes | narrower | specializes | inexact | unmatched | disjoint */
export declare enum ConceptMapGroupElementTargetEquivalence {
    Disjoint = "disjoint",
    Equal = "equal",
    Specializes = "specializes",
    Subsumes = "subsumes",
    Inexact = "inexact",
    Relatedto = "relatedto",
    Wider = "wider",
    Equivalent = "equivalent",
    Unmatched = "unmatched",
    Narrower = "narrower"
}
/** Concept in target system for element */
export interface ConceptMapTarget extends BackboneElement {
    _code?: Element;
    dependsOn?: Array<ConceptMapGroupElementTargetDependsOn>;
    _equivalence?: Element;
    /** Other concepts that this mapping also produces */
    product?: Array<ConceptMapGroupElementTargetDependsOn>;
    /** Description of status/issues in mapping */
    comment?: string;
    /** Code that identifies the target element */
    code?: code;
    /** Display for the code */
    display?: string;
    /** relatedto | equivalent | equal | wider | subsumes | narrower | specializes | inexact | unmatched | disjoint */
    equivalence: `${ConceptMapGroupElementTargetEquivalence}`;
    _comment?: Element;
    _display?: Element;
}
/** Mappings for a concept from the source set */
export interface ConceptMapElement extends BackboneElement {
    /** Identifies element being mapped */
    code?: code;
    _code?: Element;
    /** Display for the code */
    display?: string;
    _display?: Element;
    /** Concept in target system for element */
    target?: Array<ConceptMapTarget>;
}
/** Same source and target systems */
export interface ConceptMapGroup extends BackboneElement {
    _sourceVersion?: Element;
    /** What to do when there is no mapping for the source concept */
    unmapped?: ConceptMapUnmapped;
    /** Mappings for a concept from the source set */
    element: Array<ConceptMapElement>;
    _targetVersion?: Element;
    /** Specific version of the  code system */
    targetVersion?: string;
    /** Source system where concepts to be mapped are defined */
    source?: uri;
    /** Specific version of the  code system */
    sourceVersion?: string;
    _target?: Element;
    /** Target system that the concepts are to be mapped to */
    target?: uri;
    _source?: Element;
}
/** draft | active | retired | unknown */
export declare enum ConceptMapStatus {
    Active = "active",
    Draft = "draft",
    Retired = "retired",
    Unknown = "unknown"
}
/** Other elements required for this mapping (from context) */
export interface ConceptMapGroupElementTargetDependsOn extends BackboneElement {
    /** Reference to property mapping depends on */
    property: uri;
    _property?: Element;
    /** Code System (if necessary) */
    system?: canonical;
    _system?: Element;
    /** Value of the referenced element */
    value: string;
    _value?: Element;
    /** Display for the code (if value is a code) */
    display?: string;
    _display?: Element;
}
